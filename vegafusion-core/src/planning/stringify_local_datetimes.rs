/*
 * VegaFusion
 * Copyright (C) 2022 VegaFusion Technologies LLC
 *
 * This program is distributed under multiple licenses.
 * Please consult the license documentation provided alongside
 * this program the details of the active license.
 */
use crate::error::Result;
use crate::planning::plan::PlannerWarnings;
use crate::planning::stitch::CommPlan;
use crate::proto::gen::tasks::{Variable, VariableNamespace};
use crate::spec::chart::{ChartSpec, ChartVisitor, MutChartVisitor};
use crate::spec::data::DataSpec;
use crate::spec::mark::{MarkEncodingField, MarkSpec};
use crate::spec::scale::{ScaleSpec, ScaleTypeSpec};
use crate::spec::transform::formula::FormulaTransformSpec;
use crate::spec::transform::TransformSpec;
use crate::task_graph::graph::ScopedVariable;
use crate::task_graph::scope::TaskScope;
use itertools::sorted;
use std::collections::{HashMap, HashSet};

/// This planning phase converts select datetime columns from the default millisecond UTC
/// representation to naive datetime strings in an "output timezone". This is only done for datetime
/// columns that are scaled using a (non-utc) `time` scale in the client specification.
///
/// This is needed in order for the chart displayed by the client to be consistent regardless of
/// the browser's local timezone.  Viewers from all timezones should see the chart displayed as
/// it would look when generated by pure Vega in the `output_tz` timezone.
pub fn stringify_local_datetimes(
    server_spec: &mut ChartSpec,
    client_spec: &mut ChartSpec,
    comm_plan: &CommPlan,
    warnings: &mut Vec<PlannerWarnings>,
) -> Result<()> {
    // Build task scope for client spec
    let client_scope = client_spec.to_task_scope()?;

    // Collect the name/scope of all time scales
    let mut visitor = CollectScalesTypesVisitor::new();
    client_spec.walk(&mut visitor)?;
    let local_time_scales = visitor.scale_types;

    // Gather candidate datasets
    let candidate_datasets: HashSet<_> = comm_plan
        .server_to_client
        .iter()
        .cloned()
        .filter(|var| var.0.namespace == VariableNamespace::Data as i32)
        .collect();

    // Collect data fields to convert to datetime strings
    let mut visitor = CollectLocalTimeScaledFieldsVisitor::new(
        client_scope,
        local_time_scales,
        candidate_datasets,
    );
    client_spec.walk(&mut visitor)?;
    let local_datetime_fields = visitor.get_local_datetime_fields(warnings);

    // Add formula transforms to server spec
    let server_scope = server_spec.to_task_scope()?;
    let mut visitor =
        StringifyLocalDatetimeFieldsVisitor::new(local_datetime_fields.clone(), server_scope);
    server_spec.walk_mut(&mut visitor)?;

    // Add format spec to client spec (to parse strings as local dates)
    let mut visitor = FormatLocalDatetimeFieldsVisitor::new(local_datetime_fields);
    client_spec.walk_mut(&mut visitor)?;

    Ok(())
}

/// Visitor to collect the non-UTC time scales
struct CollectScalesTypesVisitor {
    pub scale_types: HashMap<ScopedVariable, ScaleTypeSpec>,
}

impl CollectScalesTypesVisitor {
    pub fn new() -> Self {
        Self {
            scale_types: Default::default(),
        }
    }
}

impl ChartVisitor for CollectScalesTypesVisitor {
    fn visit_scale(&mut self, scale: &ScaleSpec, scope: &[u32]) -> Result<()> {
        let var = (Variable::new_scale(&scale.name), Vec::from(scope));
        self.scale_types
            .insert(var, scale.type_.clone().unwrap_or(ScaleTypeSpec::Linear));
        Ok(())
    }
}

/// Visitor to collect data fields that are scaled by a non-UTC time scale
struct CollectLocalTimeScaledFieldsVisitor {
    pub scope: TaskScope,
    pub candidate_datasets: HashSet<ScopedVariable>,
    pub scale_types: HashMap<ScopedVariable, ScaleTypeSpec>,
    pub data_fields_scale_types: HashMap<ScopedVariable, HashMap<String, HashSet<ScaleTypeSpec>>>,
}

impl CollectLocalTimeScaledFieldsVisitor {
    pub fn new(
        scope: TaskScope,
        scale_types: HashMap<ScopedVariable, ScaleTypeSpec>,
        candidate_datasets: HashSet<ScopedVariable>,
    ) -> Self {
        Self {
            scope,
            candidate_datasets,
            scale_types,
            data_fields_scale_types: Default::default(),
        }
    }

    pub fn get_local_datetime_fields(
        &self,
        warnings: &mut Vec<PlannerWarnings>,
    ) -> HashMap<ScopedVariable, HashSet<String>> {
        let mut local_datetime_fields: HashMap<ScopedVariable, HashSet<String>> =
            Default::default();

        for (dataset_var, field_scale_types) in &self.data_fields_scale_types {
            for (field, scale_types) in field_scale_types {
                // Check if field is scaled with a Time scale
                if scale_types.contains(&ScaleTypeSpec::Time) {
                    let fields = local_datetime_fields
                        .entry(dataset_var.clone())
                        .or_default();
                    fields.insert(field.clone());

                    // Check if field is scaled with other scales
                    if scale_types.len() > 1 {
                        let other_scales: Vec<_> = scale_types
                            .iter()
                            .cloned()
                            .filter(|scale_type| !matches!(scale_type, ScaleTypeSpec::Time))
                            .map(|scale_type| {
                                serde_json::to_string(&scale_type)
                                    .expect("Failed to convert scale type to JSON string")
                            })
                            .collect();
                        let other_scales = other_scales.join(", ");
                        warnings.push(PlannerWarnings::StringifyDatetimeMixedUsage(
                            format!("Field \"{}\" of dataset \"{}\" is scaled using both time and the following non-time scales: {}", field, dataset_var.0.name, other_scales)
                        ))
                    }
                }
            }
        }

        local_datetime_fields
    }
}

impl ChartVisitor for CollectLocalTimeScaledFieldsVisitor {
    fn visit_non_group_mark(&mut self, mark: &MarkSpec, scope: &[u32]) -> Result<()> {
        if let Some(mark_from) = &mark.from {
            if let Some(mark_data) = &mark_from.data {
                let data_var = Variable::new_data(mark_data);
                let resolved_data = self.scope.resolve_scope(&data_var, scope)?;
                let resolved_data_scoped = (resolved_data.var.clone(), resolved_data.scope);
                if self.candidate_datasets.contains(&resolved_data_scoped) {
                    // We've found a mark with a dataset that is eligible for date string
                    // conversion
                    if let Some(encode) = &mark.encode {
                        for (_, encodings) in encode.encodings.iter() {
                            for (_, channels) in encodings.channels.iter() {
                                for channel in channels.to_vec() {
                                    if let (Some(scale), Some(MarkEncodingField::Field(field))) =
                                        (&channel.scale, &channel.field)
                                    {
                                        let scale_var = Variable::new_scale(scale);
                                        let resolved_scale =
                                            self.scope.resolve_scope(&scale_var, scope)?;
                                        let resolved_scoped_scale = (
                                            resolved_scale.var.clone(),
                                            resolved_scale.scope.clone(),
                                        );

                                        if let Some(scale_type) =
                                            self.scale_types.get(&resolved_scoped_scale)
                                        {
                                            let dataset = self
                                                .data_fields_scale_types
                                                .entry(resolved_data_scoped.clone());
                                            let fields = dataset.or_default();

                                            let field_entry = fields.entry(field.clone());
                                            let scale_types = field_entry.or_default();
                                            scale_types.insert(scale_type.clone());
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        Ok(())
    }
}

/// Visitor to stringify select datetime fields
struct StringifyLocalDatetimeFieldsVisitor {
    pub local_datetime_fields: HashMap<ScopedVariable, HashSet<String>>,
    pub scope: TaskScope,
}

impl StringifyLocalDatetimeFieldsVisitor {
    pub fn new(
        local_datetime_fields: HashMap<ScopedVariable, HashSet<String>>,
        scope: TaskScope,
    ) -> Self {
        Self {
            local_datetime_fields,
            scope,
        }
    }
}

impl MutChartVisitor for StringifyLocalDatetimeFieldsVisitor {
    fn visit_data(&mut self, data: &mut DataSpec, scope: &[u32]) -> Result<()> {
        let data_var = (Variable::new_data(&data.name), Vec::from(scope));
        if let Some(fields) = self.local_datetime_fields.get(&data_var) {
            for field in sorted(fields) {
                let expr_str = format!("timeFormat(datum['{}'], '%Y-%m-%d %H:%M:%S.%L')", field);

                let transforms = &mut data.transform;
                let transform = FormulaTransformSpec {
                    expr: expr_str,
                    as_: field.to_string(),
                    extra: Default::default(),
                };
                transforms.push(TransformSpec::Formula(transform))
            }
        }

        // Check if dataset is a child a stringified dataset. If so, we need to convert
        // datetime strings back to the utc millisecond representation
        if let Some(source) = &data.source {
            let source_var = Variable::new_data(source);
            let source_resolved = self.scope.resolve_scope(&source_var, scope)?;
            let source_resolved_var = (source_resolved.var, source_resolved.scope);
            if let Some(fields) = self.local_datetime_fields.get(&source_resolved_var) {
                for field in sorted(fields) {
                    let expr_str = format!("toDate(datum['{}'])", field);
                    let transforms = &mut data.transform;
                    let transform = FormulaTransformSpec {
                        expr: expr_str,
                        as_: field.to_string(),
                        extra: Default::default(),
                    };
                    transforms.insert(0, TransformSpec::Formula(transform))
                }
            }
        }

        Ok(())
    }
}

/// Visitor to add format parse specification for local dates
struct FormatLocalDatetimeFieldsVisitor {
    pub local_datetime_fields: HashMap<ScopedVariable, HashSet<String>>,
}

impl FormatLocalDatetimeFieldsVisitor {
    pub fn new(local_datetime_fields: HashMap<ScopedVariable, HashSet<String>>) -> Self {
        Self {
            local_datetime_fields,
        }
    }
}

impl MutChartVisitor for FormatLocalDatetimeFieldsVisitor {
    fn visit_data(&mut self, data: &mut DataSpec, scope: &[u32]) -> Result<()> {
        let data_var = (Variable::new_data(&data.name), Vec::from(scope));
        if let Some(fields) = self.local_datetime_fields.get(&data_var) {
            for field in sorted(fields) {
                let transforms = &mut data.transform;
                let transform = FormulaTransformSpec {
                    expr: format!("toDate(datum['{}'])", field),
                    as_: field.to_string(),
                    extra: Default::default(),
                };
                transforms.insert(0, TransformSpec::Formula(transform))
            }
        }

        Ok(())
    }
}
